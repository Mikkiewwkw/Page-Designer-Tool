{"ast":null,"code":"'use strict';\n\nexports.stringToBytes = string => [...string].map(character => character.charCodeAt(0));\n\nconst uint8ArrayUtf8ByteString = (array, start, end) => {\n  return String.fromCharCode(...array.slice(start, end));\n};\n\nexports.readUInt64LE = (buffer, offset = 0) => {\n  let n = buffer[offset];\n  let mul = 1;\n  let i = 0;\n\n  while (++i < 8) {\n    mul *= 0x100;\n    n += buffer[offset + i] * mul;\n  }\n\n  return n;\n};\n\nexports.tarHeaderChecksumMatches = buffer => {\n  // Does not check if checksum field characters are valid\n  if (buffer.length < 512) {\n    // `tar` header size, cannot compute checksum without it\n    return false;\n  }\n\n  const MASK_8TH_BIT = 0x80;\n  let sum = 256; // Intitalize sum, with 256 as sum of 8 spaces in checksum field\n\n  let signedBitSum = 0; // Initialize signed bit sum\n\n  for (let i = 0; i < 148; i++) {\n    const byte = buffer[i];\n    sum += byte;\n    signedBitSum += byte & MASK_8TH_BIT; // Add signed bit to signed bit sum\n  } // Skip checksum field\n\n\n  for (let i = 156; i < 512; i++) {\n    const byte = buffer[i];\n    sum += byte;\n    signedBitSum += byte & MASK_8TH_BIT; // Add signed bit to signed bit sum\n  }\n\n  const readSum = parseInt(uint8ArrayUtf8ByteString(buffer, 148, 154), 8); // Read sum in header\n  // Some implementations compute checksum incorrectly using signed bytes\n\n  return (// Checksum in header equals the sum we calculated\n    readSum === sum || // Checksum in header equals sum we calculated plus signed-to-unsigned delta\n    readSum === sum - (signedBitSum << 1)\n  );\n};\n\nexports.uint8ArrayUtf8ByteString = uint8ArrayUtf8ByteString;","map":null,"metadata":{},"sourceType":"script"}